import{i as S,d as h,E as le,L as st,t as J,g as R,I as ve,k as nt,c as ot,R as it}from"./decorators.Bi_N-DOk.js";function at(e,t){const r=e.emit;if(r._isPiped)return;const s=function(o,...i){return t.emit(o,...i),r.call(this,o,...i)};s._isPiped=!0,e.emit=s}function lt(e){const t=[...e];return Object.freeze(t),t}class ct{subscriptions=[];dispose(){let t;for(;t=this.subscriptions.shift();)t()}}class ut{constructor(t){this.initialHandlers=t,this.handlers=[...t]}handlers;prepend(t){this.handlers.unshift(...t)}reset(t){this.handlers=t.length>0?[...t]:[...this.initialHandlers]}currentHandlers(){return this.handlers}}class ht extends ct{handlersController;emitter;publicEmitter;events;constructor(...t){super(),S(this.validateHandlers(t),h.formatMessage("Failed to apply given request handlers: invalid input. Did you forget to spread the request handlers Array?")),this.handlersController=new ut(t),this.emitter=new le,this.publicEmitter=new le,at(this.emitter,this.publicEmitter),this.events=this.createLifeCycleEvents(),this.subscriptions.push(()=>{this.emitter.removeAllListeners(),this.publicEmitter.removeAllListeners()})}validateHandlers(t){return t.every(r=>!Array.isArray(r))}use(...t){S(this.validateHandlers(t),h.formatMessage('Failed to call "use()" with the given request handlers: invalid input. Did you forget to spread the array of request handlers?')),this.handlersController.prepend(t)}restoreHandlers(){this.handlersController.currentHandlers().forEach(t=>{"isUsed"in t&&(t.isUsed=!1)})}resetHandlers(...t){this.handlersController.reset(t)}listHandlers(){return lt(this.handlersController.currentHandlers())}createLifeCycleEvents(){return{on:(...t)=>this.publicEmitter.on(...t),removeListener:(...t)=>this.publicEmitter.removeListener(...t),removeAllListeners:(...t)=>this.publicEmitter.removeAllListeners(...t)}}}function we(e){return globalThis[e]||void 0}function dt(e,t){globalThis[e]=t}function ft(e){delete globalThis[e]}var pt=class{constructor(t){this.symbol=t,this.readyState="INACTIVE",this.emitter=new le,this.subscriptions=[],this.logger=new st(t.description),this.emitter.setMaxListeners(0),this.logger.info("constructing the interceptor...")}checkEnvironment(){return!0}apply(){const t=this.logger.extend("apply");if(t.info("applying the interceptor..."),this.readyState==="APPLIED"){t.info("intercepted already applied!");return}if(!this.checkEnvironment()){t.info("the interceptor cannot be applied in this environment!");return}this.readyState="APPLYING";const s=this.getInstance();if(s){t.info("found a running instance, reusing..."),this.on=(n,o)=>(t.info('proxying the "%s" listener',n),s.emitter.addListener(n,o),this.subscriptions.push(()=>{s.emitter.removeListener(n,o),t.info('removed proxied "%s" listener!',n)}),this),this.readyState="APPLIED";return}t.info("no running instance found, setting up a new instance..."),this.setup(),this.setInstance(),this.readyState="APPLIED"}setup(){}on(t,r){const s=this.logger.extend("on");return this.readyState==="DISPOSING"||this.readyState==="DISPOSED"?(s.info("cannot listen to events, already disposed!"),this):(s.info('adding "%s" event listener:',t,r),this.emitter.on(t,r),this)}once(t,r){return this.emitter.once(t,r),this}off(t,r){return this.emitter.off(t,r),this}removeAllListeners(t){return this.emitter.removeAllListeners(t),this}dispose(){const t=this.logger.extend("dispose");if(this.readyState==="DISPOSED"){t.info("cannot dispose, already disposed!");return}if(t.info("disposing the interceptor..."),this.readyState="DISPOSING",!this.getInstance()){t.info("no interceptors running, skipping dispose...");return}if(this.clearInstance(),t.info("global symbol deleted:",we(this.symbol)),this.subscriptions.length>0){t.info("disposing of %d subscriptions...",this.subscriptions.length);for(const r of this.subscriptions)r();this.subscriptions=[],t.info("disposed of all subscriptions!",this.subscriptions.length)}this.emitter.removeAllListeners(),t.info("destroyed the listener!"),this.readyState="DISPOSED"}getInstance(){var t;const r=we(this.symbol);return this.logger.info("retrieved global instance:",(t=r?.constructor)==null?void 0:t.name),r}setInstance(){dt(this.symbol,this),this.logger.info("set global instance!",this.symbol.description)}clearInstance(){ft(this.symbol),this.logger.info("cleared global instance!",this.symbol.description)}};function gt(){return Math.random().toString(16).slice(2)}function mt(){const e=(t,r)=>{e.state="pending",e.resolve=s=>{if(e.state!=="pending")return;e.result=s;const n=o=>(e.state="fulfilled",o);return t(s instanceof Promise?s:Promise.resolve(s).then(n))},e.reject=s=>{if(e.state==="pending")return queueMicrotask(()=>{e.state="rejected"}),r(e.rejectionReason=s)}};return e}var yt=class extends Promise{#e;resolve;reject;constructor(t=null){const r=mt();super((s,n)=>{r(s,n),t?.(r.resolve,r.reject)}),this.#e=r,this.resolve=this.#e.resolve,this.reject=this.#e.reject}get state(){return this.#e.state}get rejectionReason(){return this.#e.rejectionReason}then(t,r){return this.#t(super.then(t,r))}catch(t){return this.#t(super.catch(t))}finally(t){return this.#t(super.finally(t))}#t(t){return Object.defineProperties(t,{resolve:{configurable:!0,value:this.resolve},reject:{configurable:!0,value:this.reject}})}};function H(e){return e!=null&&typeof e=="object"&&!Array.isArray(e)}function Y(e){return e instanceof Blob?e.size:H(e)&&"byteLength"in e?e.byteLength:new Blob([e]).size}const Ee=24;function te(e){return e.length<=Ee?e:`${e.slice(0,Ee)}…`}async function Q(e){if(e instanceof Blob){const t=await e.text();return`Blob(${te(t)})`}if(H(e)){const t=new TextDecoder().decode(e);return`ArrayBuffer(${te(t)})`}return te(e)}const P={system:"#3b82f6",outgoing:"#22c55e",incoming:"#ef4444",mocked:"#ff6a33"};function bt(e){const{client:t,server:r}=e;vt(t),t.addEventListener("message",s=>{kt(s)}),t.addEventListener("close",s=>{wt(s)}),t.socket.addEventListener("error",s=>{Et(s)}),t.send=new Proxy(t.send,{apply(s,n,o){const[i]=o,l=new MessageEvent("message",{data:i});return Object.defineProperties(l,{currentTarget:{enumerable:!0,writable:!1,value:t.socket},target:{enumerable:!0,writable:!1,value:t.socket}}),queueMicrotask(()=>{Lt(l)}),Reflect.apply(s,n,o)}}),r.addEventListener("open",()=>{r.addEventListener("message",s=>{Rt(s)})},{once:!0}),r.send=new Proxy(r.send,{apply(s,n,o){const[i]=o,l=new MessageEvent("message",{data:i});return Object.defineProperties(l,{currentTarget:{enumerable:!0,writable:!1,value:r.socket},target:{enumerable:!0,writable:!1,value:r.socket}}),St(l),Reflect.apply(s,n,o)}})}function vt(e){const t=J(e.url);console.groupCollapsed(h.formatMessage(`${R()} %c▶%c ${t}`),`color:${P.system}`,"color:inherit"),console.log("Client:",e.socket),console.groupEnd()}function wt(e){const t=e.target,r=J(t.url);console.groupCollapsed(h.formatMessage(`${R({milliseconds:!0})} %c■%c ${r}`),`color:${P.system}`,"color:inherit"),console.log(e),console.groupEnd()}function Et(e){const t=e.target,r=J(t.url);console.groupCollapsed(h.formatMessage(`${R({milliseconds:!0})} %c×%c ${r}`),`color:${P.system}`,"color:inherit"),console.log(e),console.groupEnd()}async function kt(e){const t=Y(e.data),r=await Q(e.data),s=e.defaultPrevented?"⇡":"⬆";console.groupCollapsed(h.formatMessage(`${R({milliseconds:!0})} %c${s}%c ${r} %c${t}%c`),`color:${P.outgoing}`,"color:inherit","color:gray;font-weight:normal","color:inherit;font-weight:inherit"),console.log(e),console.groupEnd()}async function St(e){const t=Y(e.data),r=await Q(e.data);console.groupCollapsed(h.formatMessage(`${R({milliseconds:!0})} %c⬆%c ${r} %c${t}%c`),`color:${P.mocked}`,"color:inherit","color:gray;font-weight:normal","color:inherit;font-weight:inherit"),console.log(e),console.groupEnd()}async function Lt(e){const t=Y(e.data),r=await Q(e.data);console.groupCollapsed(h.formatMessage(`${R({milliseconds:!0})} %c⬇%c ${r} %c${t}%c`),`color:${P.mocked}`,"color:inherit","color:gray;font-weight:normal","color:inherit;font-weight:inherit"),console.log(e),console.groupEnd()}async function Rt(e){const t=Y(e.data),r=await Q(e.data),s=e.defaultPrevented?"⇣":"⬇";console.groupCollapsed(h.formatMessage(`${R({milliseconds:!0})} %c${s}%c ${r} %c${t}%c`),`color:${P.incoming}`,"color:inherit","color:gray;font-weight:normal","color:inherit;font-weight:inherit"),console.log(e),console.groupEnd()}async function Pt(e){try{return[null,await e().catch(t=>{throw t})]}catch(t){return[t,null]}}const Ct=async({request:e,requestId:t,handlers:r,resolutionContext:s})=>{let n=null,o=null;for(const i of r)if(o=await i.run({request:e,requestId:t,resolutionContext:s}),o!==null&&(n=i),o?.response)break;return n?{handler:n,parsedResult:o?.parsedResult,response:o?.response}:null};function qt(e){const t=new URL(e.url);return t.protocol==="file:"||/(fonts\.googleapis\.com)/.test(t.hostname)||/node_modules/.test(t.pathname)||t.pathname.includes("@vite")?!0:/\.(s?css|less|m?jsx?|m?tsx?|html|ttf|otf|woff|woff2|eot|gif|jpe?g|png|avif|webp|svg|mp4|webm|ogg|mov|mp3|wav|ogg|flac|aac|pdf|txt|csv|json|xml|md|zip|tar|gz|rar|7z)$/i.test(t.pathname)}async function Me(e,t="warn"){const r=new URL(e.url),s=J(r)+r.search,n=e.method==="HEAD"||e.method==="GET"?null:await e.clone().text(),i=`intercepted a request without a matching request handler:${`

  • ${e.method} ${s}

${n?`  • Request body: ${n}

`:""}`}If you still wish to intercept this unhandled request, please create a request handler for it.
Read more: https://mswjs.io/docs/http/intercepting-requests`;function l(a){switch(a){case"error":throw h.error("Error: %s",i),new ve(h.formatMessage('Cannot bypass a request when using the "error" strategy for the "onUnhandledRequest" option.'));case"warn":{h.warn("Warning: %s",i);break}case"bypass":break;default:throw new ve(h.formatMessage('Failed to react to an unhandled request: unknown strategy "%s". Please provide one of the supported strategies ("bypass", "warn", "error") or a custom callback function as the value of the "onUnhandledRequest" option.',a))}}if(typeof t=="function"){t(e,{warning:l.bind(null,"warn"),error:l.bind(null,"error")});return}qt(e)||l(t)}async function Tt(e,t){const r=Reflect.get(t,nt);r&&await ot.setCookie(r,e.url)}async function We(e,t,r,s,n,o){if(n.emit("request:start",{request:e,requestId:t}),e.headers.get("accept")?.includes("msw/passthrough")){n.emit("request:end",{request:e,requestId:t}),o?.onPassthroughResponse?.(e);return}const[i,l]=await Pt(()=>Ct({request:e,requestId:t,handlers:r,resolutionContext:o?.resolutionContext}));if(i)throw n.emit("unhandledException",{error:i,request:e,requestId:t}),i;if(!l){await Me(e,s.onUnhandledRequest),n.emit("request:unhandled",{request:e,requestId:t}),n.emit("request:end",{request:e,requestId:t}),o?.onPassthroughResponse?.(e);return}const{response:a}=l;if(!a){n.emit("request:end",{request:e,requestId:t}),o?.onPassthroughResponse?.(e);return}if(a.status===302&&a.headers.get("x-msw-intention")==="passthrough"){n.emit("request:end",{request:e,requestId:t}),o?.onPassthroughResponse?.(e);return}await Tt(e,a),n.emit("request:match",{request:e,requestId:t});const c=l;return o?.onMockedResponse?.(a,c),n.emit("request:end",{request:e,requestId:t}),a}function Ae(e,t){return Object.entries(t).reduce((r,[s,n])=>{const o=r[s];return Array.isArray(o)&&Array.isArray(n)?(r[s]=o.concat(n),r):H(o)&&H(n)?(r[s]=Ae(o,n),r):(r[s]=n,r)},Object.assign({},e))}function xt(e){return{status:e.status,statusText:e.statusText,headers:Object.fromEntries(e.headers.entries())}}function pe(e){return t=>t!=null&&typeof t=="object"&&"__kind"in t&&t.__kind===e}async function Ot(e,t,...r){const s=e.listeners(t);if(s.length!==0)for(const n of s)await n.apply(e,r)}function It(e){const t=Object.getOwnPropertyDescriptor(globalThis,e);return typeof t>"u"||typeof t.get=="function"&&typeof t.get()>"u"||typeof t.get>"u"&&t.value==null?!1:typeof t.set>"u"&&!t.configurable?(console.error(`[MSW] Failed to apply interceptor: the global \`${e}\` property is non-configurable. This is likely an issue with your environment. If you are using a framework, please open an issue about this in their repository.`),!1):!0}function f(e,t){return Object.defineProperties(t,{target:{value:e,enumerable:!0,writable:!0},currentTarget:{value:e,enumerable:!0,writable:!0}}),t}var x=Symbol("kCancelable"),m=Symbol("kDefaultPrevented"),ge=class extends MessageEvent{constructor(e,t){super(e,t),this[x]=!!t.cancelable,this[m]=!1}get cancelable(){return this[x]}set cancelable(e){this[x]=e}get defaultPrevented(){return this[m]}set defaultPrevented(e){this[m]=e}preventDefault(){this.cancelable&&!this[m]&&(this[m]=!0)}},Z=class extends Event{constructor(e,t={}){super(e,t),this.code=t.code===void 0?0:t.code,this.reason=t.reason===void 0?"":t.reason,this.wasClean=t.wasClean===void 0?!1:t.wasClean}},ke=class extends Z{constructor(e,t={}){super(e,t),this[x]=!!t.cancelable,this[m]=!1}get cancelable(){return this[x]}set cancelable(e){this[x]=e}get defaultPrevented(){return this[m]}set defaultPrevented(e){this[m]=e}preventDefault(){this.cancelable&&!this[m]&&(this[m]=!0)}},M=Symbol("kEmitter"),$=Symbol("kBoundListener"),Mt=class{constructor(e,t){this.socket=e,this.transport=t,this.id=gt(),this.url=new URL(e.url),this[M]=new EventTarget,this.transport.addEventListener("outgoing",r=>{const s=f(this.socket,new ge("message",{data:r.data,origin:r.origin,cancelable:!0}));this[M].dispatchEvent(s),s.defaultPrevented&&r.preventDefault()}),this.transport.addEventListener("close",r=>{this[M].dispatchEvent(f(this.socket,new Z("close",r)))})}addEventListener(e,t,r){if(!Reflect.has(t,$)){const s=t.bind(this.socket);Object.defineProperty(t,$,{value:s,enumerable:!1,configurable:!1})}this[M].addEventListener(e,Reflect.get(t,$),r)}removeEventListener(e,t,r){this[M].removeEventListener(e,Reflect.get(t,$),r)}send(e){this.transport.send(e)}close(e,t){this.transport.close(e,t)}},Se="InvalidAccessError: close code out of user configurable range",V=Symbol("kPassthroughPromise"),_e=Symbol("kOnSend"),N=Symbol("kClose"),U=class extends EventTarget{constructor(e,t){super(),this.CONNECTING=0,this.OPEN=1,this.CLOSING=2,this.CLOSED=3,this._onopen=null,this._onmessage=null,this._onerror=null,this._onclose=null,this.url=e.toString(),this.protocol="",this.extensions="",this.binaryType="blob",this.readyState=this.CONNECTING,this.bufferedAmount=0,this[V]=new yt,queueMicrotask(async()=>{await this[V]||(this.protocol=typeof t=="string"?t:Array.isArray(t)&&t.length>0?t[0]:"",this.readyState===this.CONNECTING&&(this.readyState=this.OPEN,this.dispatchEvent(f(this,new Event("open")))))})}set onopen(e){this.removeEventListener("open",this._onopen),this._onopen=e,e!==null&&this.addEventListener("open",e)}get onopen(){return this._onopen}set onmessage(e){this.removeEventListener("message",this._onmessage),this._onmessage=e,e!==null&&this.addEventListener("message",e)}get onmessage(){return this._onmessage}set onerror(e){this.removeEventListener("error",this._onerror),this._onerror=e,e!==null&&this.addEventListener("error",e)}get onerror(){return this._onerror}set onclose(e){this.removeEventListener("close",this._onclose),this._onclose=e,e!==null&&this.addEventListener("close",e)}get onclose(){return this._onclose}send(e){if(this.readyState===this.CONNECTING)throw this.close(),new DOMException("InvalidStateError");this.readyState===this.CLOSING||this.readyState===this.CLOSED||(this.bufferedAmount+=Wt(e),queueMicrotask(()=>{var t;this.bufferedAmount=0,(t=this[_e])==null||t.call(this,e)}))}close(e=1e3,t){S(e,Se),S(e===1e3||e>=3e3&&e<=4999,Se),this[N](e,t)}[N](e=1e3,t,r=!0){this.readyState===this.CLOSING||this.readyState===this.CLOSED||(this.readyState=this.CLOSING,queueMicrotask(()=>{this.readyState=this.CLOSED,this.dispatchEvent(f(this,new Z("close",{code:e,reason:t,wasClean:r}))),this._onopen=null,this._onmessage=null,this._onerror=null,this._onclose=null}))}addEventListener(e,t,r){return super.addEventListener(e,t,r)}removeEventListener(e,t,r){return super.removeEventListener(e,t,r)}};U.CONNECTING=0;U.OPEN=1;U.CLOSING=2;U.CLOSED=3;function Wt(e){return typeof e=="string"?e.length:e instanceof Blob?e.size:e.byteLength}var w=Symbol("kEmitter"),G=Symbol("kBoundListener"),re=Symbol("kSend"),At=class{constructor(e,t,r){this.client=e,this.transport=t,this.createConnection=r,this[w]=new EventTarget,this.mockCloseController=new AbortController,this.realCloseController=new AbortController,this.transport.addEventListener("outgoing",s=>{typeof this.realWebSocket>"u"||queueMicrotask(()=>{s.defaultPrevented||this[re](s.data)})}),this.transport.addEventListener("incoming",this.handleIncomingMessage.bind(this))}get socket(){return S(this.realWebSocket,'Cannot access "socket" on the original WebSocket server object: the connection is not open. Did you forget to call `server.connect()`?'),this.realWebSocket}connect(){S(!this.realWebSocket||this.realWebSocket.readyState!==WebSocket.OPEN,'Failed to call "connect()" on the original WebSocket instance: the connection already open');const e=this.createConnection();e.binaryType=this.client.binaryType,e.addEventListener("open",t=>{this[w].dispatchEvent(f(this.realWebSocket,new Event("open",t)))},{once:!0}),e.addEventListener("message",t=>{this.transport.dispatchEvent(f(this.realWebSocket,new MessageEvent("incoming",{data:t.data,origin:t.origin})))}),this.client.addEventListener("close",t=>{this.handleMockClose(t)},{signal:this.mockCloseController.signal}),e.addEventListener("close",t=>{this.handleRealClose(t)},{signal:this.realCloseController.signal}),e.addEventListener("error",()=>{const t=f(e,new Event("error",{cancelable:!0}));this[w].dispatchEvent(t),t.defaultPrevented||this.client.dispatchEvent(f(this.client,new Event("error")))}),this.realWebSocket=e}addEventListener(e,t,r){if(!Reflect.has(t,G)){const s=t.bind(this.client);Object.defineProperty(t,G,{value:s,enumerable:!1})}this[w].addEventListener(e,Reflect.get(t,G),r)}removeEventListener(e,t,r){this[w].removeEventListener(e,Reflect.get(t,G),r)}send(e){this[re](e)}[re](e){const{realWebSocket:t}=this;if(S(t,'Failed to call "server.send()" for "%s": the connection is not open. Did you forget to call "server.connect()"?',this.client.url),!(t.readyState===WebSocket.CLOSING||t.readyState===WebSocket.CLOSED)){if(t.readyState===WebSocket.CONNECTING){t.addEventListener("open",()=>{t.send(e)},{once:!0});return}t.send(e)}}close(){const{realWebSocket:e}=this;S(e,'Failed to close server connection for "%s": the connection is not open. Did you forget to call "server.connect()"?',this.client.url),this.realCloseController.abort(),!(e.readyState===WebSocket.CLOSING||e.readyState===WebSocket.CLOSED)&&(e.close(),queueMicrotask(()=>{this[w].dispatchEvent(f(this.realWebSocket,new ke("close",{code:1e3,cancelable:!0})))}))}handleIncomingMessage(e){const t=f(e.target,new ge("message",{data:e.data,origin:e.origin,cancelable:!0}));this[w].dispatchEvent(t),t.defaultPrevented||this.client.dispatchEvent(f(this.client,new MessageEvent("message",{data:e.data,origin:e.origin})))}handleMockClose(e){this.realWebSocket&&this.realWebSocket.close()}handleRealClose(e){this.mockCloseController.abort();const t=f(this.realWebSocket,new ke("close",{code:e.code,reason:e.reason,wasClean:e.wasClean,cancelable:!0}));this[w].dispatchEvent(t),t.defaultPrevented||this.client[N](e.code,e.reason)}},_t=class extends EventTarget{constructor(e){super(),this.socket=e,this.socket.addEventListener("close",t=>{this.dispatchEvent(f(this.socket,new Z("close",t)))}),this.socket[_e]=t=>{this.dispatchEvent(f(this.socket,new ge("outgoing",{data:t,origin:this.socket.url,cancelable:!0})))}}addEventListener(e,t,r){return super.addEventListener(e,t,r)}dispatchEvent(e){return super.dispatchEvent(e)}send(e){queueMicrotask(()=>{if(this.socket.readyState===this.socket.CLOSING||this.socket.readyState===this.socket.CLOSED)return;const t=()=>{this.socket.dispatchEvent(f(this.socket,new MessageEvent("message",{data:e,origin:this.socket.url})))};this.socket.readyState===this.socket.CONNECTING?this.socket.addEventListener("open",()=>{t()},{once:!0}):t()})}close(e,t){this.socket[N](e,t)}},De=class extends pt{constructor(){super(De.symbol)}checkEnvironment(){return It("WebSocket")}setup(){const e=Object.getOwnPropertyDescriptor(globalThis,"WebSocket"),t=new Proxy(globalThis.WebSocket,{construct:(r,s,n)=>{const[o,i]=s,l=()=>Reflect.construct(r,s,n),a=new U(o,i),c=new _t(a);return queueMicrotask(async()=>{try{const u=new At(a,c,l),d=this.emitter.listenerCount("connection")>0;await Ot(this.emitter,"connection",{client:new Mt(a,c),server:u,info:{protocols:i}}),d?a[V].resolve(!1):(a[V].resolve(!0),u.connect(),u.addEventListener("open",()=>{a.dispatchEvent(f(a,new Event("open"))),u.realWebSocket&&(a.protocol=u.realWebSocket.protocol)}))}catch(u){u instanceof Error&&(a.dispatchEvent(new Event("error")),a.readyState!==WebSocket.CLOSING&&a.readyState!==WebSocket.CLOSED&&a[N](1011,u.message,!1),console.error(u))}}),a}});Object.defineProperty(globalThis,"WebSocket",{value:t,configurable:!0}),this.subscriptions.push(()=>{Object.defineProperty(globalThis,"WebSocket",e)})}},je=De;je.symbol=Symbol("websocket");const ce=new je;function Dt(e){ce.on("connection",async t=>{const r=e.getHandlers().filter(pe("EventHandler"));if(r.length>0){e?.onMockedConnection(t),await Promise.all(r.map(n=>n.run(t)));return}const s=new Request(t.client.url,{headers:{upgrade:"websocket",connection:"upgrade"}});await Me(s,e.getUnhandledRequestStrategy()).catch(n=>{const o=new Event("error");Object.defineProperty(o,"cause",{enumerable:!0,configurable:!1,value:n}),t.client.socket.dispatchEvent(o)}),e?.onPassthroughConnection(t),t.server.connect()})}var jt={},Ht=/(%?)(%([sdijo]))/g;function Nt(e,t){switch(t){case"s":return e;case"d":case"i":return Number(e);case"j":return JSON.stringify(e);case"o":{if(typeof e=="string")return e;const r=JSON.stringify(e);return r==="{}"||r==="[]"||/^\[object .+?\]$/.test(r)?e:r}}}function B(e,...t){if(t.length===0)return e;let r=0,s=e.replace(Ht,(n,o,i,l)=>{const a=t[r],c=Nt(a,l);return o?n:(r++,c)});return r<t.length&&(s+=` ${t.slice(r).join(" ")}`),s=s.replace(/%{2,2}/g,"%"),s}var Ut=2;function Bt(e){if(!e.stack)return;const t=e.stack.split(`
`);t.splice(1,Ut),e.stack=t.join(`
`)}var $t=class extends Error{constructor(e,...t){super(e),this.message=e,this.name="Invariant Violation",this.message=B(e,...t),Bt(this)}},y=(e,t,...r)=>{if(!e)throw new $t(t,...r)};y.as=(e,t,r,...s)=>{if(!t){const n=s.length===0?r:B(r,...s);let o;try{o=Reflect.construct(e,[n])}catch{o=e(n)}throw o}};function me(){if(typeof navigator<"u"&&navigator.product==="ReactNative")return!0;if(typeof process<"u"){const e=process.type;return e==="renderer"||e==="worker"?!1:!!(process.versions&&process.versions.node)}return!1}function Gt(){const e=(t,r)=>{e.state="pending",e.resolve=s=>{if(e.state!=="pending")return;e.result=s;const n=o=>(e.state="fulfilled",o);return t(s instanceof Promise?s:Promise.resolve(s).then(n))},e.reject=s=>{if(e.state==="pending")return queueMicrotask(()=>{e.state="rejected"}),r(e.rejectionReason=s)}};return e}var C=class extends Promise{#e;resolve;reject;constructor(e=null){const t=Gt();super((r,s)=>{t(r,s),e?.(t.resolve,t.reject)}),this.#e=t,this.resolve=this.#e.resolve,this.reject=this.#e.reject}get state(){return this.#e.state}get rejectionReason(){return this.#e.rejectionReason}then(e,t){return this.#t(super.then(e,t))}catch(e){return this.#t(super.catch(e))}finally(e){return this.#t(super.finally(e))}#t(e){return Object.defineProperties(e,{resolve:{configurable:!0,value:this.resolve},reject:{configurable:!0,value:this.reject}})}},Ft={serviceWorker:{url:"/mockServiceWorker.js",options:null},quiet:!1,waitUntilReady:!0,onUnhandledRequest:"warn",findWorker(e,t){return e===t}};async function Xt(e){try{return[null,await e().catch(t=>{throw t})]}catch(t){return[t,null]}}function zt(e){return new URL(e,location.href).href}function se(e,t,r){return[e.active,e.installing,e.waiting].filter(i=>i!=null).find(i=>r(i.scriptURL,t))||null}var Vt=async(e,t={},r)=>{const s=zt(e),n=await navigator.serviceWorker.getRegistrations().then(a=>a.filter(c=>se(c,s,r)));!navigator.serviceWorker.controller&&n.length>0&&location.reload();const[o]=n;if(o)return o.update(),[se(o,s,r),o];const[i,l]=await Xt(async()=>{const a=await navigator.serviceWorker.register(e,t);return[se(a,s,r),a]});if(i){if(i.message.includes("(404)")){const c=new URL(t?.scope||"/",location.href);throw new Error(h.formatMessage(`Failed to register a Service Worker for scope ('${c.href}') with script ('${s}'): Service Worker script does not exist at the given path.

Did you forget to run "npx msw init <PUBLIC_DIR>"?

Learn more about creating the Service Worker script: https://mswjs.io/docs/cli/init`))}throw new Error(h.formatMessage(`Failed to register the Service Worker:

%s`,i.message))}return l};function He(e={}){if(e.quiet)return;const t=e.message||"Mocking enabled.";console.groupCollapsed(`%c${h.formatMessage(t)}`,"color:orangered;font-weight:bold;"),console.log("%cDocumentation: %chttps://mswjs.io/docs","font-weight:bold","font-weight:normal"),console.log("Found an issue? https://github.com/mswjs/msw/issues"),e.workerUrl&&console.log("Worker script URL:",e.workerUrl),e.workerScope&&console.log("Worker scope:",e.workerScope),e.client&&console.log("Client ID: %s (%s)",e.client.id,e.client.frameType),console.groupEnd()}function Kt(e,t){const r=new C;return e.workerChannel.postMessage("MOCK_ACTIVATE"),e.workerChannel.once("MOCKING_ENABLED",async s=>{e.isMockingEnabled=!0;const n=await e.workerPromise;He({quiet:t.quiet,workerScope:e.registration?.scope,workerUrl:n.scriptURL,client:s.data.client}),r.resolve(!0)}),r}function Jt(e){if(!["HEAD","GET"].includes(e.method))return e.body}function Ne(e){return new Request(e.url,{...e,body:Jt(e)})}function ue(){return typeof navigator<"u"&&"serviceWorker"in navigator&&typeof location<"u"&&location.protocol!=="file:"}function Yt(){try{const e=new ReadableStream({start:r=>r.close()});return new MessageChannel().port1.postMessage(e,[e]),!0}catch{return!1}}var Qt=Yt(),Zt=(e,t)=>async r=>{if(!e.isMockingEnabled&&e.workerStoppedAt&&r.data.interceptedAt>e.workerStoppedAt){r.postMessage("PASSTHROUGH");return}const s=r.data.id,n=Ne(r.data),o=n.clone(),i=n.clone();it.cache.set(n,i);try{await We(n,s,e.getRequestHandlers().filter(pe("RequestHandler")),t,e.emitter,{onPassthroughResponse(){r.postMessage("PASSTHROUGH")},async onMockedResponse(l,{handler:a,parsedResult:c}){const u=l.clone(),d=l.clone(),p=xt(l);if(Qt){const I=l.body;r.postMessage("MOCK_RESPONSE",{...p,body:I},I?[I]:void 0)}else{const I=l.body===null?null:await u.arrayBuffer();r.postMessage("MOCK_RESPONSE",{...p,body:I})}t.quiet||e.emitter.once("response:mocked",()=>{a.log({request:o,response:d,parsedResult:c})})}})}catch(l){l instanceof Error&&(h.error(`Uncaught exception in the request handler for "%s %s":

%s

This exception has been gracefully handled as a 500 response, however, it's strongly recommended to resolve this error, as it indicates a mistake in your code. If you wish to mock an error response, please see this guide: https://mswjs.io/docs/http/mocking-responses/error-responses`,n.method,n.url,l.stack??l),r.postMessage("MOCK_RESPONSE",{status:500,statusText:"Request Handler Error",headers:{"Content-Type":"application/json"},body:JSON.stringify({name:l.name,message:l.message,stack:l.stack})}))}};function er(e){const t=new C;return e.workerChannel.postMessage("INTEGRITY_CHECK_REQUEST"),e.workerChannel.once("INTEGRITY_CHECK_RESPONSE",r=>{const{checksum:s,packageVersion:n}=r.data;s!=="4db4a41e972cec1b64cc569c66952d82"&&h.warn(`The currently registered Service Worker has been generated by a different version of MSW (${n}) and may not be fully compatible with the installed version.

It's recommended you update your worker script by running this command:

  • npx msw init <PUBLIC_DIR>

You can also automate this process and make the worker script update automatically upon the library installations. Read more: https://mswjs.io/docs/cli/init.`),t.resolve()}),t}var tr=new TextEncoder;function rr(e){return tr.encode(e)}function sr(e,t){return new TextDecoder(t).decode(e)}function nr(e){return e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength)}var or=Object.defineProperty,ir=(e,t)=>{for(var r in t)or(e,r,{get:t[r],enumerable:!0})},he={};ir(he,{blue:()=>lr,gray:()=>de,green:()=>ur,red:()=>cr,yellow:()=>ar});function ar(e){return`\x1B[33m${e}\x1B[0m`}function lr(e){return`\x1B[34m${e}\x1B[0m`}function de(e){return`\x1B[90m${e}\x1B[0m`}function cr(e){return`\x1B[31m${e}\x1B[0m`}function ur(e){return`\x1B[32m${e}\x1B[0m`}var ee=me(),Ue=class{constructor(e){this.name=e,this.prefix=`[${this.name}]`;const t=Le("DEBUG"),r=Le("LOG_LEVEL");t==="1"||t==="true"||typeof t<"u"&&this.name.startsWith(t)?(this.debug=W(r,"debug")?g:this.debug,this.info=W(r,"info")?g:this.info,this.success=W(r,"success")?g:this.success,this.warning=W(r,"warning")?g:this.warning,this.error=W(r,"error")?g:this.error):(this.info=g,this.success=g,this.warning=g,this.error=g,this.only=g)}prefix;extend(e){return new Ue(`${this.name}:${e}`)}debug(e,...t){this.logEntry({level:"debug",message:de(e),positionals:t,prefix:this.prefix,colors:{prefix:"gray"}})}info(e,...t){this.logEntry({level:"info",message:e,positionals:t,prefix:this.prefix,colors:{prefix:"blue"}});const r=new hr;return(s,...n)=>{r.measure(),this.logEntry({level:"info",message:`${s} ${de(`${r.deltaTime}ms`)}`,positionals:n,prefix:this.prefix,colors:{prefix:"blue"}})}}success(e,...t){this.logEntry({level:"info",message:e,positionals:t,prefix:`✔ ${this.prefix}`,colors:{timestamp:"green",prefix:"green"}})}warning(e,...t){this.logEntry({level:"warning",message:e,positionals:t,prefix:`⚠ ${this.prefix}`,colors:{timestamp:"yellow",prefix:"yellow"}})}error(e,...t){this.logEntry({level:"error",message:e,positionals:t,prefix:`✖ ${this.prefix}`,colors:{timestamp:"red",prefix:"red"}})}only(e){e()}createEntry(e,t){return{timestamp:new Date,level:e,message:t}}logEntry(e){const{level:t,message:r,prefix:s,colors:n,positionals:o=[]}=e,i=this.createEntry(t,r),l=n?.timestamp||"gray",a=n?.prefix||"gray",c={timestamp:he[l],prefix:he[a]};this.getWriter(t)([c.timestamp(this.formatTimestamp(i.timestamp))].concat(s!=null?c.prefix(s):[]).concat(Re(r)).join(" "),...o.map(Re))}formatTimestamp(e){return`${e.toLocaleTimeString("en-GB")}:${e.getMilliseconds()}`}getWriter(e){switch(e){case"debug":case"success":case"info":return dr;case"warning":return fr;case"error":return pr}}},hr=class{startTime;endTime;deltaTime;constructor(){this.startTime=performance.now()}measure(){this.endTime=performance.now();const e=this.endTime-this.startTime;this.deltaTime=e.toFixed(2)}},g=()=>{};function dr(e,...t){if(ee){process.stdout.write(B(e,...t)+`
`);return}console.log(e,...t)}function fr(e,...t){if(ee){process.stderr.write(B(e,...t)+`
`);return}console.warn(e,...t)}function pr(e,...t){if(ee){process.stderr.write(B(e,...t)+`
`);return}console.error(e,...t)}function Le(e){return ee?jt[e]:globalThis[e]?.toString()}function W(e,t){return e!==void 0&&e!==t}function Re(e){return typeof e>"u"?"undefined":e===null?"null":typeof e=="string"?e:typeof e=="object"?JSON.stringify(e):e.toString()}var gr=class extends Error{constructor(e,t,r){super(`Possible EventEmitter memory leak detected. ${r} ${t.toString()} listeners added. Use emitter.setMaxListeners() to increase limit`),this.emitter=e,this.type=t,this.count=r,this.name="MaxListenersExceededWarning"}},Be=class{static listenerCount(e,t){return e.listenerCount(t)}constructor(){this.events=new Map,this.maxListeners=Be.defaultMaxListeners,this.hasWarnedAboutPotentialMemoryLeak=!1}_emitInternalEvent(e,t,r){this.emit(e,t,r)}_getListeners(e){return Array.prototype.concat.apply([],this.events.get(e))||[]}_removeListener(e,t){const r=e.indexOf(t);return r>-1&&e.splice(r,1),[]}_wrapOnceListener(e,t){const r=(...s)=>(this.removeListener(e,r),t.apply(this,s));return Object.defineProperty(r,"name",{value:t.name}),r}setMaxListeners(e){return this.maxListeners=e,this}getMaxListeners(){return this.maxListeners}eventNames(){return Array.from(this.events.keys())}emit(e,...t){const r=this._getListeners(e);return r.forEach(s=>{s.apply(this,t)}),r.length>0}addListener(e,t){this._emitInternalEvent("newListener",e,t);const r=this._getListeners(e).concat(t);if(this.events.set(e,r),this.maxListeners>0&&this.listenerCount(e)>this.maxListeners&&!this.hasWarnedAboutPotentialMemoryLeak){this.hasWarnedAboutPotentialMemoryLeak=!0;const s=new gr(this,e,this.listenerCount(e));console.warn(s)}return this}on(e,t){return this.addListener(e,t)}once(e,t){return this.addListener(e,this._wrapOnceListener(e,t))}prependListener(e,t){const r=this._getListeners(e);if(r.length>0){const s=[t].concat(r);this.events.set(e,s)}else this.events.set(e,r.concat(t));return this}prependOnceListener(e,t){return this.prependListener(e,this._wrapOnceListener(e,t))}removeListener(e,t){const r=this._getListeners(e);return r.length>0&&(this._removeListener(r,t),this.events.set(e,r),this._emitInternalEvent("removeListener",e,t)),this}off(e,t){return this.removeListener(e,t)}removeAllListeners(e){return e?this.events.delete(e):this.events.clear(),this}listeners(e){return Array.from(this._getListeners(e))}listenerCount(e){return this._getListeners(e).length}rawListeners(e){return this.listeners(e)}},$e=Be;$e.defaultMaxListeners=10;var mr=(e,t,r)=>{if(!t.has(e))throw TypeError("Cannot "+r)},ne=(e,t,r)=>(mr(e,t,"read from private field"),r?r.call(e):t.get(e)),yr=(e,t,r)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,r)},br="x-interceptors-internal-request-id";function Pe(e){return globalThis[e]||void 0}function vr(e,t){globalThis[e]=t}function wr(e){delete globalThis[e]}var ye=class{constructor(e){this.symbol=e,this.readyState="INACTIVE",this.emitter=new $e,this.subscriptions=[],this.logger=new Ue(e.description),this.emitter.setMaxListeners(0),this.logger.info("constructing the interceptor...")}checkEnvironment(){return!0}apply(){const e=this.logger.extend("apply");if(e.info("applying the interceptor..."),this.readyState==="APPLIED"){e.info("intercepted already applied!");return}if(!this.checkEnvironment()){e.info("the interceptor cannot be applied in this environment!");return}this.readyState="APPLYING";const r=this.getInstance();if(r){e.info("found a running instance, reusing..."),this.on=(s,n)=>(e.info('proxying the "%s" listener',s),r.emitter.addListener(s,n),this.subscriptions.push(()=>{r.emitter.removeListener(s,n),e.info('removed proxied "%s" listener!',s)}),this),this.readyState="APPLIED";return}e.info("no running instance found, setting up a new instance..."),this.setup(),this.setInstance(),this.readyState="APPLIED"}setup(){}on(e,t){const r=this.logger.extend("on");return this.readyState==="DISPOSING"||this.readyState==="DISPOSED"?(r.info("cannot listen to events, already disposed!"),this):(r.info('adding "%s" event listener:',e,t),this.emitter.on(e,t),this)}once(e,t){return this.emitter.once(e,t),this}off(e,t){return this.emitter.off(e,t),this}removeAllListeners(e){return this.emitter.removeAllListeners(e),this}dispose(){const e=this.logger.extend("dispose");if(this.readyState==="DISPOSED"){e.info("cannot dispose, already disposed!");return}if(e.info("disposing the interceptor..."),this.readyState="DISPOSING",!this.getInstance()){e.info("no interceptors running, skipping dispose...");return}if(this.clearInstance(),e.info("global symbol deleted:",Pe(this.symbol)),this.subscriptions.length>0){e.info("disposing of %d subscriptions...",this.subscriptions.length);for(const t of this.subscriptions)t();this.subscriptions=[],e.info("disposed of all subscriptions!",this.subscriptions.length)}this.emitter.removeAllListeners(),e.info("destroyed the listener!"),this.readyState="DISPOSED"}getInstance(){var e;const t=Pe(this.symbol);return this.logger.info("retrieved global instance:",(e=t?.constructor)==null?void 0:e.name),t}setInstance(){vr(this.symbol,this),this.logger.info("set global instance!",this.symbol.description)}clearInstance(){wr(this.symbol),this.logger.info("cleared global instance!",this.symbol.description)}};function Ge(){return Math.random().toString(16).slice(2)}var O=Symbol("isPatchedModule"),D=class extends Error{constructor(e){super(e),this.name="InterceptorError",Object.setPrototypeOf(this,D.prototype)}},_,X,E=class{constructor(e,t){this.request=e,this.source=t,yr(this,_),this.readyState=E.PENDING,this.handled=new C}async passthrough(){y.as(D,this.readyState===E.PENDING,'Failed to passthrough the "%s %s" request: the request has already been handled',this.request.method,this.request.url),this.readyState=E.PASSTHROUGH,await this.source.passthrough(),ne(this,_,X).resolve()}respondWith(e){y.as(D,this.readyState===E.PENDING,'Failed to respond to the "%s %s" request with "%d %s": the request has already been handled (%d)',this.request.method,this.request.url,e.status,e.statusText||"OK",this.readyState),this.readyState=E.RESPONSE,ne(this,_,X).resolve(),this.source.respondWith(e)}errorWith(e){y.as(D,this.readyState===E.PENDING,'Failed to error the "%s %s" request with "%s": the request has already been handled (%d)',this.request.method,this.request.url,e?.toString(),this.readyState),this.readyState=E.ERROR,this.source.errorWith(e),ne(this,_,X).resolve()}},b=E;_=new WeakSet;X=function(){return this.handled};b.PENDING=0;b.PASSTHROUGH=1;b.RESPONSE=2;b.ERROR=3;function Fe(e){try{return new URL(e),!0}catch{return!1}}function Ce(e,t){const s=Object.getOwnPropertySymbols(t).find(n=>n.description===e);if(s)return Reflect.get(t,s)}var T=class extends Response{static isConfigurableStatusCode(e){return e>=200&&e<=599}static isRedirectResponse(e){return T.STATUS_CODES_WITH_REDIRECT.includes(e)}static isResponseWithBody(e){return!T.STATUS_CODES_WITHOUT_BODY.includes(e)}static setUrl(e,t){if(!e||e==="about:"||!Fe(e))return;const r=Ce("state",t);r?r.urlList.push(new URL(e)):Object.defineProperty(t,"url",{value:e,enumerable:!0,configurable:!0,writable:!1})}static parseRawHeaders(e){const t=new Headers;for(let r=0;r<e.length;r+=2)t.append(e[r],e[r+1]);return t}constructor(e,t={}){var r;const s=(r=t.status)!=null?r:200,n=T.isConfigurableStatusCode(s)?s:200,o=T.isResponseWithBody(s)?e:null;if(super(o,{status:n,statusText:t.statusText,headers:t.headers}),s!==n){const i=Ce("state",this);i?i.status=s:Object.defineProperty(this,"status",{value:s,enumerable:!0,configurable:!0,writable:!1})}T.setUrl(t.url,this)}},v=T;v.STATUS_CODES_WITHOUT_BODY=[101,103,204,205,304];v.STATUS_CODES_WITH_REDIRECT=[301,302,303,307,308];var Er=Symbol("kRawRequest");function Xe(e,t){Reflect.set(e,Er,t)}var fe=class extends ye{constructor(e){fe.symbol=Symbol(e.name),super(fe.symbol),this.interceptors=e.interceptors}setup(){const e=this.logger.extend("setup");e.info("applying all %d interceptors...",this.interceptors.length);for(const t of this.interceptors)e.info('applying "%s" interceptor...',t.constructor.name),t.apply(),e.info("adding interceptor dispose subscription"),this.subscriptions.push(()=>t.dispose())}on(e,t){for(const r of this.interceptors)r.on(e,t);return this}once(e,t){for(const r of this.interceptors)r.once(e,t);return this}off(e,t){for(const r of this.interceptors)r.off(e,t);return this}removeAllListeners(e){for(const t of this.interceptors)t.removeAllListeners(e);return this}};function kr(e){return t=>{const r=t.data,s=Ne(r.request);if(r.response.type?.includes("opaque"))return;const n=r.response.status===0?Response.error():new v(v.isResponseWithBody(r.response.status)?r.response.body:null,{...r.response,url:s.url});e.emitter.emit(r.isMockedResponse?"response:mocked":"response:bypass",{requestId:r.request.id,request:s,response:n})}}function Sr(e,t){!t?.quiet&&!location.href.startsWith(e.scope)&&h.warn(`Cannot intercept requests on this page because it's outside of the worker's scope ("${e.scope}"). If you wish to mock API requests on this page, you must resolve this scope issue.

- (Recommended) Register the worker at the root level ("/") of your application.
- Set the "Service-Worker-Allowed" response header to allow out-of-scope workers.`)}var Lr=e=>function(r,s){return(async()=>{e.workerChannel.removeAllListeners(),e.workerChannel.on("REQUEST",Zt(e,r)),e.workerChannel.on("RESPONSE",kr(e));const i=await Vt(r.serviceWorker.url,r.serviceWorker.options,r.findWorker),[l,a]=i;if(!l){const c=s?.findWorker?h.formatMessage(`Failed to locate the Service Worker registration using a custom "findWorker" predicate.

Please ensure that the custom predicate properly locates the Service Worker registration at "%s".
More details: https://mswjs.io/docs/api/setup-worker/start#findworker
`,r.serviceWorker.url):h.formatMessage(`Failed to locate the Service Worker registration.

This most likely means that the worker script URL "%s" cannot resolve against the actual public hostname (%s). This may happen if your application runs behind a proxy, or has a dynamic hostname.

Please consider using a custom "serviceWorker.url" option to point to the actual worker script location, or a custom "findWorker" option to resolve the Service Worker registration manually. More details: https://mswjs.io/docs/api/setup-worker/start`,r.serviceWorker.url,location.host);throw new Error(c)}return e.workerPromise.resolve(l),e.registration=a,window.addEventListener("beforeunload",()=>{l.state!=="redundant"&&e.workerChannel.postMessage("CLIENT_CLOSED"),window.clearInterval(e.keepAliveInterval),window.postMessage({type:"msw/worker:stop"})}),await er(e).catch(c=>{h.error("Error while checking the worker script integrity. Please report this on GitHub (https://github.com/mswjs/msw/issues) and include the original error below."),console.error(c)}),e.keepAliveInterval=window.setInterval(()=>e.workerChannel.postMessage("KEEPALIVE_REQUEST"),5e3),Sr(a,e.startOptions),a})().then(async i=>{const l=i.installing||i.waiting;if(l){const a=new C;l.addEventListener("statechange",()=>{l.state==="activated"&&a.resolve()}),await a}return await Kt(e,r).catch(a=>{throw h.error("Failed to enable mocking. Please report this on GitHub (https://github.com/mswjs/msw/issues) and include the original error below."),a}),i})},F=Symbol("kDefaultPrevented"),k=Symbol("kPropagationStopped"),j=Symbol("kImmediatePropagationStopped"),Rr=class extends MessageEvent{#e;[F];[k];[j];constructor(...e){super(e[0],e[1]),this[F]=!1}get defaultPrevented(){return this[F]}preventDefault(){super.preventDefault(),this[F]=!0}stopImmediatePropagation(){super.stopImmediatePropagation(),this[j]=!0}},qe=Symbol("kListenerOptions"),Pr=class{#e;constructor(){this.#e={}}on(e,t,r){return this.#t(e,t,r)}once(e,t,r){return this.on(e,t,{...r||{},once:!0})}earlyOn(e,t,r){return this.#t(e,t,r,"prepend")}earlyOnce(e,t,r){return this.earlyOn(e,t,{...r||{},once:!0})}emit(e){if(this.listenerCount(e.type)===0)return!1;const t=this.#r(e);for(const r of this.#e[e.type]){if(t.event[k]!=null&&t.event[k]!==this)return!1;if(t.event[j])break;this.#s(t.event,r)}return t.revoke(),!0}async emitAsPromise(e){if(this.listenerCount(e.type)===0)return[];const t=[],r=this.#r(e);for(const s of this.#e[e.type]){if(r.event[k]!=null&&r.event[k]!==this)return[];if(r.event[j])break;t.push(await Promise.resolve(this.#s(r.event,s)))}return r.revoke(),Promise.allSettled(t).then(s=>s.map(n=>n.status==="fulfilled"?n.value:n.reason))}*emitAsGenerator(e){if(this.listenerCount(e.type)===0)return;const t=this.#r(e);for(const r of this.#e[e.type]){if(t.event[k]!=null&&t.event[k]!==this)return;if(t.event[j])break;yield this.#s(t.event,r)}t.revoke()}removeListener(e,t){if(this.listenerCount(e)===0)return;const r=[];for(const s of this.#e[e])s!==t&&r.push(s);this.#e[e]=r}removeAllListeners(e){if(e==null){this.#e={};return}this.#e[e]=[]}listeners(e){return e==null?Object.values(this.#e).flat():this.#e[e]||[]}listenerCount(e){return this.listeners(e).length}#t(e,t,r,s="append"){return this.#e[e]??=[],s==="prepend"?this.#e[e].unshift(t):this.#e[e].push(t),r&&(Object.defineProperty(t,qe,{value:r,enumerable:!1,writable:!1}),r.signal&&r.signal.addEventListener("abort",()=>{this.removeListener(e,t)},{once:!0})),this}#r(e){const{stopPropagation:t}=e;return e.stopPropagation=new Proxy(e.stopPropagation,{apply:(r,s,n)=>(e[k]=this,Reflect.apply(r,s,n))}),{event:e,revoke(){e.stopPropagation=t}}}#s(e,t){const r=t.call(this,e);return t[qe]?.once&&this.removeListener(e.type,t),r}},Te=ue(),Cr=class extends Rr{#e;constructor(e){const t=e.data.type,r=e.data.payload;super(t,{data:r}),this.#e=e}get ports(){return this.#e.ports}postMessage(e,...t){this.#e.ports[0].postMessage({type:e,data:t[0]},{transfer:t[1]})}},qr=class extends Pr{constructor(e){super(),this.options=e,Te&&navigator.serviceWorker.addEventListener("message",async t=>{const r=await this.options.worker;t.source!=null&&t.source!==r||t.data&&H(t.data)&&"type"in t.data&&this.emit(new Cr(t))})}postMessage(e){y(Te,"Failed to post message on a WorkerChannel: the Service Worker API is unavailable in this context. This is likely an issue with MSW. Please report it on GitHub: https://github.com/mswjs/msw/issues"),this.options.worker.then(t=>{t.postMessage(e)})}};async function K(e,t,...r){const s=e.listeners(t);if(s.length!==0)for(const n of s)await n.apply(e,r)}function ze(e){const t=Object.getOwnPropertyDescriptor(globalThis,e);return typeof t>"u"||typeof t.get=="function"&&typeof t.get()>"u"||typeof t.get>"u"&&t.value==null?!1:typeof t.set>"u"&&!t.configurable?(console.error(`[MSW] Failed to apply interceptor: the global \`${e}\` property is non-configurable. This is likely an issue with your environment. If you are using a framework, please open an issue about this in their repository.`),!1):!0}var Ve=async e=>{try{return{error:null,data:await e().catch(r=>{throw r})}}catch(t){return{error:t,data:null}}};function Ke(e,t=!1){return t?Object.prototype.toString.call(e).startsWith("[object "):Object.prototype.toString.call(e)==="[object Object]"}function z(e,t){try{return e[t],!0}catch{return!1}}function Tr(e){return new Response(JSON.stringify(e instanceof Error?{name:e.name,message:e.message,stack:e.stack}:e),{status:500,statusText:"Unhandled Exception",headers:{"Content-Type":"application/json"}})}function be(e){return e!=null&&e instanceof Response&&z(e,"type")&&e.type==="error"}function xr(e){return Ke(e,!0)&&z(e,"status")&&z(e,"statusText")&&z(e,"bodyUsed")}function Or(e){return e==null||!(e instanceof Error)?!1:"code"in e&&"errno"in e}async function Je(e){const t=async o=>o instanceof Error?(await e.controller.errorWith(o),!0):be(o)?(await e.controller.respondWith(o),!0):xr(o)?(await e.controller.respondWith(o),!0):Ke(o)?(await e.controller.errorWith(o),!0):!1,r=async o=>{if(o instanceof D)throw n.error;return Or(o)?(await e.controller.errorWith(o),!0):o instanceof Response?await t(o):!1},s=new C;if(e.request.signal){if(e.request.signal.aborted){await e.controller.errorWith(e.request.signal.reason);return}e.request.signal.addEventListener("abort",()=>{s.reject(e.request.signal.reason)},{once:!0})}const n=await Ve(async()=>{const o=K(e.emitter,"request",{requestId:e.requestId,request:e.request,controller:e.controller});await Promise.race([s,o,e.controller.handled])});if(s.state==="rejected"){await e.controller.errorWith(s.rejectionReason);return}if(n.error){if(await r(n.error))return;if(e.emitter.listenerCount("unhandledException")>0){const o=new b(e.request,{passthrough(){},async respondWith(i){await t(i)},async errorWith(i){await e.controller.errorWith(i)}});if(await K(e.emitter,"unhandledException",{error:n.error,request:e.request,requestId:e.requestId,controller:o}),o.readyState!==b.PENDING)return}await e.controller.respondWith(Tr(n.error));return}return e.controller.readyState===b.PENDING?await e.controller.passthrough():e.controller.handled}function L(e){return Object.assign(new TypeError("Failed to fetch"),{cause:e})}var Ir=["content-encoding","content-language","content-location","content-type","content-length"],oe=Symbol("kRedirectCount");async function Mr(e,t){if(t.status!==303&&e.body!=null)return Promise.reject(L());const r=new URL(e.url);let s;try{s=new URL(t.headers.get("location"),e.url)}catch(i){return Promise.reject(L(i))}if(!(s.protocol==="http:"||s.protocol==="https:"))return Promise.reject(L("URL scheme must be a HTTP(S) scheme"));if(Reflect.get(e,oe)>20)return Promise.reject(L("redirect count exceeded"));if(Object.defineProperty(e,oe,{value:(Reflect.get(e,oe)||0)+1}),e.mode==="cors"&&(s.username||s.password)&&!xe(r,s))return Promise.reject(L('cross origin not allowed for request mode "cors"'));const n={};([301,302].includes(t.status)&&e.method==="POST"||t.status===303&&!["HEAD","GET"].includes(e.method))&&(n.method="GET",n.body=null,Ir.forEach(i=>{e.headers.delete(i)})),xe(r,s)||(e.headers.delete("authorization"),e.headers.delete("proxy-authorization"),e.headers.delete("cookie"),e.headers.delete("host")),n.headers=e.headers;const o=await fetch(new Request(s,n));return Object.defineProperty(o,"redirected",{value:!0,configurable:!0}),o}function xe(e,t){return e.origin===t.origin&&e.origin==="null"||e.protocol===t.protocol&&e.hostname===t.hostname&&e.port===t.port}var Wr=class extends TransformStream{constructor(){console.warn("[Interceptors]: Brotli decompression of response streams is not supported in the browser"),super({transform(e,t){t.enqueue(e)}})}},Ar=class extends TransformStream{constructor(e,...t){super({},...t);const r=[super.readable,...e].reduce((s,n)=>s.pipeThrough(n));Object.defineProperty(this,"readable",{get(){return r}})}};function _r(e){return e.toLowerCase().split(",").map(t=>t.trim())}function Dr(e){if(e==="")return null;const t=_r(e);if(t.length===0)return null;const r=t.reduceRight((s,n)=>n==="gzip"||n==="x-gzip"?s.concat(new DecompressionStream("gzip")):n==="deflate"?s.concat(new DecompressionStream("deflate")):n==="br"?s.concat(new Wr):(s.length=0,s),[]);return new Ar(r)}function jr(e){if(e.body===null)return null;const t=Dr(e.headers.get("content-encoding")||"");return t?(e.body.pipeTo(t.writable),t.readable):null}var Ye=class extends ye{constructor(){super(Ye.symbol)}checkEnvironment(){return ze("fetch")}async setup(){const e=globalThis.fetch;y(!e[O],'Failed to patch the "fetch" module: already patched.'),globalThis.fetch=async(t,r)=>{const s=Ge(),n=typeof t=="string"&&typeof location<"u"&&!Fe(t)?new URL(t,location.href):t,o=new Request(n,r);t instanceof Request&&Xe(o,t);const i=new C,l=new b(o,{passthrough:async()=>{this.logger.info("request has not been handled, passthrough...");const a=o.clone(),{error:c,data:u}=await Ve(()=>e(o));if(c)return i.reject(c);if(this.logger.info("original fetch performed",u),this.emitter.listenerCount("response")>0){this.logger.info('emitting the "response" event...');const d=u.clone();await K(this.emitter,"response",{response:d,isMockedResponse:!1,request:a,requestId:s})}i.resolve(u)},respondWith:async a=>{if(be(a)){this.logger.info("request has errored!",{response:a}),i.reject(L(a));return}this.logger.info("received mocked response!",{rawResponse:a});const c=jr(a),u=c===null?a:new v(c,a);if(v.setUrl(o.url,u),v.isRedirectResponse(u.status)){if(o.redirect==="error"){i.reject(L("unexpected redirect"));return}if(o.redirect==="follow"){Mr(o,u).then(d=>{i.resolve(d)},d=>{i.reject(d)});return}}this.emitter.listenerCount("response")>0&&(this.logger.info('emitting the "response" event...'),await K(this.emitter,"response",{response:u.clone(),isMockedResponse:!0,request:o,requestId:s})),i.resolve(u)},errorWith:a=>{this.logger.info("request has been aborted!",{reason:a}),i.reject(a)}});return this.logger.info("[%s] %s",o.method,o.url),this.logger.info("awaiting for the mocked response..."),this.logger.info('emitting the "request" event for %s listener(s)...',this.emitter.listenerCount("request")),await Je({request:o,requestId:s,emitter:this.emitter,controller:l}),i},Object.defineProperty(globalThis.fetch,O,{enumerable:!0,configurable:!0,value:!0}),this.subscriptions.push(()=>{Object.defineProperty(globalThis.fetch,O,{value:void 0}),globalThis.fetch=e,this.logger.info('restored native "globalThis.fetch"!',globalThis.fetch.name)})}},Qe=Ye;Qe.symbol=Symbol("fetch");function Hr(e,t){const r=new Uint8Array(e.byteLength+t.byteLength);return r.set(e,0),r.set(t,e.byteLength),r}var Ze=class{constructor(e,t){this.NONE=0,this.CAPTURING_PHASE=1,this.AT_TARGET=2,this.BUBBLING_PHASE=3,this.type="",this.srcElement=null,this.currentTarget=null,this.eventPhase=0,this.isTrusted=!0,this.composed=!1,this.cancelable=!0,this.defaultPrevented=!1,this.bubbles=!0,this.lengthComputable=!0,this.loaded=0,this.total=0,this.cancelBubble=!1,this.returnValue=!0,this.type=e,this.target=t?.target||null,this.currentTarget=t?.currentTarget||null,this.timeStamp=Date.now()}composedPath(){return[]}initEvent(e,t,r){this.type=e,this.bubbles=!!t,this.cancelable=!!r}preventDefault(){this.defaultPrevented=!0}stopPropagation(){}stopImmediatePropagation(){}},Nr=class extends Ze{constructor(e,t){super(e),this.lengthComputable=t?.lengthComputable||!1,this.composed=t?.composed||!1,this.loaded=t?.loaded||0,this.total=t?.total||0}},Ur=typeof ProgressEvent<"u";function Br(e,t,r){const s=["error","progress","loadstart","loadend","load","timeout","abort"],n=Ur?ProgressEvent:Nr;return s.includes(t)?new n(t,{lengthComputable:!0,loaded:r?.loaded||0,total:r?.total||0}):new Ze(t,{target:e,currentTarget:e})}function et(e,t){if(!(t in e))return null;if(Object.prototype.hasOwnProperty.call(e,t))return e;const s=Reflect.getPrototypeOf(e);return s?et(s,t):null}function ie(e,t){return new Proxy(e,$r(t))}function $r(e){const{constructorCall:t,methodCall:r,getProperty:s,setProperty:n}=e,o={};return typeof t<"u"&&(o.construct=function(i,l,a){const c=Reflect.construct.bind(null,i,l,a);return t.call(a,l,c)}),o.set=function(i,l,a){const c=()=>{const u=et(i,l)||i,d=Reflect.getOwnPropertyDescriptor(u,l);return typeof d?.set<"u"?(d.set.apply(i,[a]),!0):Reflect.defineProperty(u,l,{writable:!0,enumerable:!0,configurable:!0,value:a})};return typeof n<"u"?n.call(i,[l,a],c):c()},o.get=function(i,l,a){const c=()=>i[l],u=typeof s<"u"?s.call(i,[l,a],c):c();return typeof u=="function"?(...d)=>{const p=u.bind(i,...d);return typeof r<"u"?r.call(i,[l,d],p):p()}:u},o}function Gr(e){return["application/xhtml+xml","application/xml","image/svg+xml","text/html","text/xml"].some(r=>e.startsWith(r))}function Fr(e){try{return JSON.parse(e)}catch{return null}}function Xr(e,t){const r=v.isResponseWithBody(e.status)?t:null;return new v(r,{url:e.responseURL,status:e.status,statusText:e.statusText,headers:zr(e.getAllResponseHeaders())})}function zr(e){const t=new Headers,r=e.split(/[\r\n]+/);for(const s of r){if(s.trim()==="")continue;const[n,...o]=s.split(": "),i=o.join(": ");t.append(n,i)}return t}async function Oe(e){const t=e.headers.get("content-length");return t!=null&&t!==""?Number(t):(await e.arrayBuffer()).byteLength}var A=Symbol("kIsRequestHandled"),Vr=me(),ae=Symbol("kFetchRequest"),Kr=class{constructor(e,t){this.initialRequest=e,this.logger=t,this.method="GET",this.url=null,this[A]=!1,this.events=new Map,this.uploadEvents=new Map,this.requestId=Ge(),this.requestHeaders=new Headers,this.responseBuffer=new Uint8Array,this.request=ie(e,{setProperty:([r,s],n)=>{switch(r){case"ontimeout":{const o=r.slice(2);return this.request.addEventListener(o,s),n()}default:return n()}},methodCall:([r,s],n)=>{switch(r){case"open":{const[o,i]=s;return typeof i>"u"?(this.method="GET",this.url=Ie(o)):(this.method=o,this.url=Ie(i)),this.logger=this.logger.extend(`${this.method} ${this.url.href}`),this.logger.info("open",this.method,this.url.href),n()}case"addEventListener":{const[o,i]=s;return this.registerEvent(o,i),this.logger.info("addEventListener",o,i),n()}case"setRequestHeader":{const[o,i]=s;return this.requestHeaders.set(o,i),this.logger.info("setRequestHeader",o,i),n()}case"send":{const[o]=s;this.request.addEventListener("load",()=>{if(typeof this.onResponse<"u"){const a=Xr(this.request,this.request.response);this.onResponse.call(this,{response:a,isMockedResponse:this[A],request:l,requestId:this.requestId})}});const i=typeof o=="string"?rr(o):o,l=this.toFetchApiRequest(i);this[ae]=l.clone(),queueMicrotask(()=>{var a;(((a=this.onRequest)==null?void 0:a.call(this,{request:l,requestId:this.requestId}))||Promise.resolve()).finally(()=>{if(!this[A])return this.logger.info("request callback settled but request has not been handled (readystate %d), performing as-is...",this.request.readyState),Vr&&this.request.setRequestHeader(br,this.requestId),n()})});break}default:return n()}}}),q(this.request,"upload",ie(this.request.upload,{setProperty:([r,s],n)=>{switch(r){case"onloadstart":case"onprogress":case"onaboart":case"onerror":case"onload":case"ontimeout":case"onloadend":{const o=r.slice(2);this.registerUploadEvent(o,s)}}return n()},methodCall:([r,s],n)=>{switch(r){case"addEventListener":{const[o,i]=s;return this.registerUploadEvent(o,i),this.logger.info("upload.addEventListener",o,i),n()}}}}))}registerEvent(e,t){const s=(this.events.get(e)||[]).concat(t);this.events.set(e,s),this.logger.info('registered event "%s"',e,t)}registerUploadEvent(e,t){const s=(this.uploadEvents.get(e)||[]).concat(t);this.uploadEvents.set(e,s),this.logger.info('registered upload event "%s"',e,t)}async respondWith(e){if(this[A]=!0,this[ae]){const s=await Oe(this[ae]);this.trigger("loadstart",this.request.upload,{loaded:0,total:s}),this.trigger("progress",this.request.upload,{loaded:s,total:s}),this.trigger("load",this.request.upload,{loaded:s,total:s}),this.trigger("loadend",this.request.upload,{loaded:s,total:s})}this.logger.info("responding with a mocked response: %d %s",e.status,e.statusText),q(this.request,"status",e.status),q(this.request,"statusText",e.statusText),q(this.request,"responseURL",this.url.href),this.request.getResponseHeader=new Proxy(this.request.getResponseHeader,{apply:(s,n,o)=>{if(this.logger.info("getResponseHeader",o[0]),this.request.readyState<this.request.HEADERS_RECEIVED)return this.logger.info("headers not received yet, returning null"),null;const i=e.headers.get(o[0]);return this.logger.info('resolved response header "%s" to',o[0],i),i}}),this.request.getAllResponseHeaders=new Proxy(this.request.getAllResponseHeaders,{apply:()=>{if(this.logger.info("getAllResponseHeaders"),this.request.readyState<this.request.HEADERS_RECEIVED)return this.logger.info("headers not received yet, returning empty string"),"";const n=Array.from(e.headers.entries()).map(([o,i])=>`${o}: ${i}`).join(`\r
`);return this.logger.info("resolved all response headers to",n),n}}),Object.defineProperties(this.request,{response:{enumerable:!0,configurable:!1,get:()=>this.response},responseText:{enumerable:!0,configurable:!1,get:()=>this.responseText},responseXML:{enumerable:!0,configurable:!1,get:()=>this.responseXML}});const t=await Oe(e.clone());this.logger.info("calculated response body length",t),this.trigger("loadstart",this.request,{loaded:0,total:t}),this.setReadyState(this.request.HEADERS_RECEIVED),this.setReadyState(this.request.LOADING);const r=()=>{this.logger.info("finalizing the mocked response..."),this.setReadyState(this.request.DONE),this.trigger("load",this.request,{loaded:this.responseBuffer.byteLength,total:t}),this.trigger("loadend",this.request,{loaded:this.responseBuffer.byteLength,total:t})};if(e.body){this.logger.info("mocked response has body, streaming...");const s=e.body.getReader(),n=async()=>{const{value:o,done:i}=await s.read();if(i){this.logger.info("response body stream done!"),r();return}o&&(this.logger.info("read response body chunk:",o),this.responseBuffer=Hr(this.responseBuffer,o),this.trigger("progress",this.request,{loaded:this.responseBuffer.byteLength,total:t})),n()};n()}else r()}responseBufferToText(){return sr(this.responseBuffer)}get response(){if(this.logger.info("getResponse (responseType: %s)",this.request.responseType),this.request.readyState!==this.request.DONE)return null;switch(this.request.responseType){case"json":{const e=Fr(this.responseBufferToText());return this.logger.info("resolved response JSON",e),e}case"arraybuffer":{const e=nr(this.responseBuffer);return this.logger.info("resolved response ArrayBuffer",e),e}case"blob":{const e=this.request.getResponseHeader("Content-Type")||"text/plain",t=new Blob([this.responseBufferToText()],{type:e});return this.logger.info("resolved response Blob (mime type: %s)",t,e),t}default:{const e=this.responseBufferToText();return this.logger.info('resolving "%s" response type as text',this.request.responseType,e),e}}}get responseText(){if(y(this.request.responseType===""||this.request.responseType==="text","InvalidStateError: The object is in invalid state."),this.request.readyState!==this.request.LOADING&&this.request.readyState!==this.request.DONE)return"";const e=this.responseBufferToText();return this.logger.info('getResponseText: "%s"',e),e}get responseXML(){if(y(this.request.responseType===""||this.request.responseType==="document","InvalidStateError: The object is in invalid state."),this.request.readyState!==this.request.DONE)return null;const e=this.request.getResponseHeader("Content-Type")||"";return typeof DOMParser>"u"?(console.warn("Cannot retrieve XMLHttpRequest response body as XML: DOMParser is not defined. You are likely using an environment that is not browser or does not polyfill browser globals correctly."),null):Gr(e)?new DOMParser().parseFromString(this.responseBufferToText(),e):null}errorWith(e){this[A]=!0,this.logger.info("responding with an error"),this.setReadyState(this.request.DONE),this.trigger("error",this.request),this.trigger("loadend",this.request)}setReadyState(e){if(this.logger.info("setReadyState: %d -> %d",this.request.readyState,e),this.request.readyState===e){this.logger.info("ready state identical, skipping transition...");return}q(this.request,"readyState",e),this.logger.info("set readyState to: %d",e),e!==this.request.UNSENT&&(this.logger.info('triggering "readystatechange" event...'),this.trigger("readystatechange",this.request))}trigger(e,t,r){const s=t[`on${e}`],n=Br(t,e,r);this.logger.info('trigger "%s"',e,r||""),typeof s=="function"&&(this.logger.info('found a direct "%s" callback, calling...',e),s.call(t,n));const o=t instanceof XMLHttpRequestUpload?this.uploadEvents:this.events;for(const[i,l]of o)i===e&&(this.logger.info('found %d listener(s) for "%s" event, calling...',l.length,e),l.forEach(a=>a.call(t,n)))}toFetchApiRequest(e){this.logger.info("converting request to a Fetch API Request...");const t=e instanceof Document?e.documentElement.innerText:e,r=new Request(this.url.href,{method:this.method,headers:this.requestHeaders,credentials:this.request.withCredentials?"include":"same-origin",body:["GET","HEAD"].includes(this.method.toUpperCase())?null:t}),s=ie(r.headers,{methodCall:([n,o],i)=>{switch(n){case"append":case"set":{const[l,a]=o;this.request.setRequestHeader(l,a);break}case"delete":{const[l]=o;console.warn(`XMLHttpRequest: Cannot remove a "${l}" header from the Fetch API representation of the "${r.method} ${r.url}" request. XMLHttpRequest headers cannot be removed.`);break}}return i()}});return q(r,"headers",s),Xe(r,this.request),this.logger.info("converted request to a Fetch API Request!",r),r}};function Ie(e){return typeof location>"u"?new URL(e):new URL(e.toString(),location.href)}function q(e,t,r){Reflect.defineProperty(e,t,{writable:!0,enumerable:!0,value:r})}function Jr({emitter:e,logger:t}){return new Proxy(globalThis.XMLHttpRequest,{construct(s,n,o){t.info("constructed new XMLHttpRequest");const i=Reflect.construct(s,n,o),l=Object.getOwnPropertyDescriptors(s.prototype);for(const c in l)Reflect.defineProperty(i,c,l[c]);const a=new Kr(i,t);return a.onRequest=async function({request:c,requestId:u}){const d=new b(c,{passthrough:()=>{this.logger.info("no mocked response received, performing request as-is...")},respondWith:async p=>{if(be(p)){this.errorWith(new TypeError("Network error"));return}await this.respondWith(p)},errorWith:p=>{this.logger.info("request errored!",{error:p}),p instanceof Error&&this.errorWith(p)}});this.logger.info("awaiting mocked response..."),this.logger.info('emitting the "request" event for %s listener(s)...',e.listenerCount("request")),await Je({request:c,requestId:u,controller:d,emitter:e})},a.onResponse=async function({response:c,isMockedResponse:u,request:d,requestId:p}){this.logger.info('emitting the "response" event for %s listener(s)...',e.listenerCount("response")),e.emit("response",{response:c,isMockedResponse:u,request:d,requestId:p})},a.request}})}var tt=class extends ye{constructor(){super(tt.interceptorSymbol)}checkEnvironment(){return ze("XMLHttpRequest")}setup(){const e=this.logger.extend("setup");e.info('patching "XMLHttpRequest" module...');const t=globalThis.XMLHttpRequest;y(!t[O],'Failed to patch the "XMLHttpRequest" module: already patched.'),globalThis.XMLHttpRequest=Jr({emitter:this.emitter,logger:this.logger}),e.info('native "XMLHttpRequest" module patched!',globalThis.XMLHttpRequest.name),Object.defineProperty(globalThis.XMLHttpRequest,O,{enumerable:!0,configurable:!0,value:!0}),this.subscriptions.push(()=>{Object.defineProperty(globalThis.XMLHttpRequest,O,{value:void 0}),globalThis.XMLHttpRequest=t,e.info('native "XMLHttpRequest" module restored!',globalThis.XMLHttpRequest.name)})}},rt=tt;rt.interceptorSymbol=Symbol("xhr");function Yr(e,t){const r=new fe({name:"fallback",interceptors:[new Qe,new rt]});return r.on("request",async({request:s,requestId:n,controller:o})=>{const i=s.clone(),l=await We(s,n,e.getRequestHandlers().filter(pe("RequestHandler")),t,e.emitter,{onMockedResponse(a,{handler:c,parsedResult:u}){t.quiet||e.emitter.once("response:mocked",({response:d})=>{c.log({request:i,response:d,parsedResult:u})})}});l&&o.respondWith(l)}),r.on("response",({response:s,isMockedResponse:n,request:o,requestId:i})=>{e.emitter.emit(n?"response:mocked":"response:bypass",{response:s,request:o,requestId:i})}),r.apply(),r}function Qr(e={}){e.quiet||console.log(`%c${h.formatMessage("Mocking disabled.")}`,"color:orangered;font-weight:bold;")}var Zr=class extends ht{context;constructor(...e){super(...e),y(!me(),h.formatMessage("Failed to execute `setupWorker` in a non-browser environment. Consider using `setupServer` for Node.js environment instead.")),this.context=this.createWorkerContext()}createWorkerContext(){const e=new C;return{isMockingEnabled:!1,startOptions:null,workerPromise:e,registration:void 0,getRequestHandlers:()=>this.handlersController.currentHandlers(),emitter:this.emitter,workerChannel:new qr({worker:e})}}async start(e={}){if("waitUntilReady"in e&&h.warn('The "waitUntilReady" option has been deprecated. Please remove it from this "worker.start()" call. Follow the recommended Browser integration (https://mswjs.io/docs/integrations/browser) to eliminate any race conditions between the Service Worker registration and any requests made by your application on initial render.'),this.context.isMockingEnabled)return h.warn('Found a redundant "worker.start()" call. Note that starting the worker while mocking is already enabled will have no effect. Consider removing this "worker.start()" call.'),this.context.registration;if(this.context.workerStoppedAt=void 0,this.context.startOptions=Ae(Ft,e),Dt({getUnhandledRequestStrategy:()=>this.context.startOptions.onUnhandledRequest,getHandlers:()=>this.handlersController.currentHandlers(),onMockedConnection:s=>{this.context.startOptions.quiet||bt(s)},onPassthroughConnection(){}}),ce.apply(),this.subscriptions.push(()=>{ce.dispose()}),!ue()){const s=Yr(this.context,this.context.startOptions);this.subscriptions.push(()=>{s.dispose()}),this.context.isMockingEnabled=!0,He({message:"Mocking enabled (fallback mode).",quiet:this.context.startOptions.quiet});return}const r=await Lr(this.context)(this.context.startOptions,e);return this.context.isMockingEnabled=!0,r}stop(){if(super.dispose(),!this.context.isMockingEnabled){h.warn('Found a redundant "worker.stop()" call. Notice that stopping the worker after it has already been stopped has no effect. Consider removing this "worker.stop()" call.');return}this.context.isMockingEnabled=!1,this.context.workerStoppedAt=Date.now(),this.context.emitter.removeAllListeners(),ue()&&(this.context.workerChannel.removeAllListeners("RESPONSE"),window.clearInterval(this.context.keepAliveInterval)),window.postMessage({type:"msw/worker:stop"}),Qr({quiet:this.context.startOptions?.quiet})}};function ss(...e){return new Zr(...e)}export{Zr as SetupWorkerApi,ss as setupWorker};
